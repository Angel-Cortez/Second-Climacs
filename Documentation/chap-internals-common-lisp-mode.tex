\chapter{\commonlisp{} mode}
\label{chap-internals-common-lisp-mode}

\section{Syntax}

The \commonlisp{} syntax maintains a tree representing the contents of
the buffer.  A node in the tree is either a \emph{code node} or
a \emph{binary tree node}.

\Defclass {code}

This class has a slot representing the position in the buffer where
this code fragment starts and ends.

\Defclass {binary-tree}

A binary tree node represents a \emph{sequence}%
\footnote{Not a \commonlisp{} sequence; just a suite.}  of code
fragments.  If a buffer contains more than one consecutive top-level
expression, then the root node of the buffer representation is a
binary-tree node.

The binary-tree nodes are treated as a \emph{splay tree}
\cite{Sleator:1985:SBS:3828.3835}, in that they can be dynamically
reorganized according to the access pattern.
There are three subclass of \texttt{code}:

\Defclass {expression}

This class is a subclass of the class \texttt{code}.  It represents a
\commonlisp{} expression.  The node has a slot containing the
expression being represented.  An expression node also
contains a slot holding its \emph{children}.  This slot may contain
\texttt{nil} if the node has no children, another expression node if
the node has exactly one child, or a binary-tree node if the node has
more than one child.

\Defclass {whitespace}

This class is a subclass of the class \texttt{code}.  It represents a
sequence of whitespace characters.

\Defclass {comment}

This class is a subclass of the class \texttt{code}.  It represents a
\commonlisp{} comment.

In order to avoid updating the entire tree whenever text is inserted
or deleted, positions of code are \emph{relative} to some other
position $p$.  A position takes the form $<l,c>$, where $l$ indicates
\emph{lines} and $c$ indicates \emph{columns}.  If $l = 0$, then $c$
is the number of columns to add to the position indicated by $p$ to
obtain the new position.  If instead $l > 0$, then $l$ indicates the
number of lines between $p$ and the new position, and $c$ is the
\emph{absolute} position from the beginning of the line.

The position given in some node $n$ is relative to its parent in the
following cases:

\begin{itemize}
\item The parent of $n$ is a code node.
\item The parent of $n$ is a binary tree node and $n$ is the
  \emph{left} child of the parent.
\item The parent of $n$ is a binary tree node, $n$ is the
  \emph{right} child of the parent, and $n$ has no left sibling.
\end{itemize}

Otherwise, i.e., if the parent of some node $n$ is a binary tree node
and $n$ is the \emph{right} child of the parent, and $n$ has a left
sibling then the position given in $n$ is relative to the left
sibling.

\commonlisp{} syntax contains a special version of the \commonlisp{}
\emph{reader}.  It differs from the standard reader in the following
ways:

\begin{itemize}
\item It never signals an error.
\item It records the start and end position of every call, as well as
  the object read.
\item Instead of calling \texttt{intern} on symbols, it merely records
  that character sequence as being a symbol in the current package. 
\end{itemize}

On the other hand, it behaves like the ordinary \commonlisp{} reader
in that it can handle custom reader macros, even though it provides
reader macros for standard macro characters that behave slightly
differently from the standard reader macros.

When some illegal syntax is encountered, it tries to do something
reasonable.  For instance if \emph{end of file} is encountered in the
middle of reading a list, the end of file is treated as terminating
the list.  When an illegal token is encountered, an object is returned
that indicates this fact. 


