\section{Computing indentation}
\label{sec-internals-common-lisp-mode-indentation}

\subsection{Introduction}

There are two basic cases for computing indentation of some parse
result:

\begin{enumerate}
\item If the parse result is a top-level parse result, then the
  indentation is always 0, i.e. it should be positioned in the
  leftmost column.
\item If the parse result is a nested parse result, then the
  indentation is relative to some ancestor parse result.
\end{enumerate}

The first case is trivial.  For the second case, computing indentation
is a top-down procedure applied to the children of some parse result
$P$.  It is assumed that the indentation (absolute or relative) of $P$
has already been computed, either because it is a top-level parse
result, or because its indentation was computed relative to some
ancestor.

We must distinguish between the following cases:

\begin{enumerate}
\item $P$ is an atomic parse result.
\item $P$ represents a special form or a function or macro call with
  its own indentation rule
\item $P$ represents a function call without its own indentation rule.
\item $P$ represents a macro call without its own indentation rule.
\end{enumerate}

In case 1,  we are done because its indentation has already been
computed.  The remaining cases are treated below.

\subsection{Special indentation rules}

Certain operators have their own indentation rules.  In particular,
most special operators do, but it is also possible to define special
indentation rules for functions and macros.

Such an indentation rule is a method on the generic-function
\texttt{compute-indentation}.  This function takes the parse result
$P$, a symbol (the name of the operator), and a \emph{client}
instance.  A method should specialize on the name of the operator (in
the form of an EQL specializer) and on the client parameter (unless
this is a default method).

The method computes and assigns indentation for the descendants that
have fixed relative indentation according to the syntax of the
operator, and then recursively calls the global indentation
computation function in order to recursively compute indentation for
the children of those descendants.

\subsection{Indenting a function call}

If $P$ represents a function call, then its children are indented
according to the following rules:

\begin{itemize}
\item If $P$ has at least two children and the second child is
  positioned on the same line as the first child, then the remaining
  children (starting with the third one) are indented so that they
  align with the second child.
\item If either $P$ has only one child (which must then be the
  function to be called), or the second child is not positioned on the
  same line as the first child, then every child is indented by two
  positions relative to $P$.
\end{itemize}

\subsection{Indenting a macro call}

The indentation of a macro call depends on the lambda list for the
macro.  Two major cases are identified:

\begin{itemize}
\item The lambda list does not have \texttt{&body} in it.
\item The lambda list has \texttt{&body} in it.
\end{itemize}

In the first case, the macro call is indented in the same way as a
function call.

In the second case, there are two sub-cases:

\begin{itemize}
\item If any of the arguments of the body is positioned on the same
  line as the operator, then every child that is not positioned on the
  same line as the operator is aligned under the first body argument.
\item Otherwise, every child that belongs to the body is indented by
  two positions relative to $P$.
\end{itemize}

If there is a child of $P$ preceding the body arguments and the first
such child is positioned on the same line as the operator, then every
child line preceding the body arguments is indented below the first
child.  Otherwise, if there is a child of $P$ preceding the body
arguments, then every line of such a child is indented by four spaces.
