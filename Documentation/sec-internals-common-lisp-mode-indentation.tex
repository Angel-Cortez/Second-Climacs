\section{Computing indentation}
\label{sec-internals-common-lisp-mode-indentation}

There are two basic cases for computing indentation of some parse
result:

\begin{enumerate}
\item If the parse result is a top-level parse result, then the
  indentation is always 0, i.e. it should be positioned in the
  leftmost column.
\item If the parse result is a nested parse result, then the
  indentation is relative to some ancestor parse result.
\end{enumerate}

The first case is trivial.  For the second case, computing indentation
is a top-down procedure applied to the children of some parse result
$P$.  It is assumed that the indentation (absolute or relative) of $P$
has already been computed, either because it is a top-level parse
result, or because its indentation was computed relative to some
ancestor.

We must distinguish between the following cases:

\begin{enumerate}
\item $P$ is an atomic parse result.
\item $P$ represents a special form or a function or macro call with
  its own indentation rule
\item $P$ represents a function call without its own indentation rule.
\item $P$ represents a macro call without its own indentation rule.
\end{enumerate}

In case 1,  we are done because its indentation has already been
computed.
