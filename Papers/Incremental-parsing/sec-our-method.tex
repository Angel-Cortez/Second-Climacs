\section{Our technique}

Our incremental parser parses the contents of a line-oriented buffer,
specified in the form of a \clos{} protocol
\cite{Strandh:2016:CPE:3005729.3005732}.  The buffer is line-oriented
in two different ways:

\begin{enumerate}
\item The editing operations specified by the protocol define a
  \emph{line} abstraction, in contrast to a buffer of GHU Emacs
  \cite{Finseth:1980:TPTa} which exposes a single sequence containing
  newline characters to indicate line separation.
\item The update protocol works on the granularity of a line.  An
  entire line can be reported as being modified, inserted, or
  deleted.
\end{enumerate}

For the purpose of this paper, the update protocol is the part of the
buffer protocol that we are interested in, because we re-parse the
buffer as a result of the update protocol having been invoked.

In order to parse the buffer contents, we use a custom \texttt{read}
function.  This version of the \texttt{read} function differs from the
standard one in the following ways:

\begin{itemize}
\item Instead of returning S-expressions, it returns a nested
  structure of instances of a standard class named
  \texttt{parse-result}.  These instances contain the corresponding
  S-expression and the start and end position (line, column) in the
  buffer of the parse result.
\item The parse results returned by the reader also include entities
  that would normally not be returned by \texttt{read} such as
  comments and (more generally), results of applying reader macros
  that return no values.
\item Instead of attempting to call \texttt{intern} in order to turn a
  token into a symbol, the custom reader returns an instance of a
  standard class named \texttt{token}.
\end{itemize}

The reader from the \sicl{} project%
\footnote{See: https://github.com/robert-strandh/SICL.}
was slightly modified to allow this kind of customization, thereby
avoid the necessity of maintaining the code for a completely separate
reader.

The update buffer protocol is typically invoked after each keystroke
by the end user, and the modifications to the buffer are typically
very modest, in that usually a single line has been modified.  It
would be wasteful, and too slow for large buffers, to re-parse the
entire buffer character by character, each time the update protocol is
invoked.  For that reason, we keep a \emph{cache} of parse results
returned by the customized reader.

This cache is organized as a sequence%
\footnote{Here, we use the word \emph{sequence} in the meaning of a
  set of items organized consecutively, and not in the more
  restrictive meaning defined by the \commonlisp{} standard.}
of top-level parse results.  Each top-level parse result contains the
parse results returned by nested calls to the reader.  The sequence of
top-level parse results is split into a \emph{prefix} and a
\emph{suffix}, typically reflecting the current location in the buffer
being edited by the end user.
